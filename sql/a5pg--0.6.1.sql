/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:229

-- Reconstruct 2D array from flattened array to match DuckDB API (coords[1][1] syntax)
CREATE OR REPLACE FUNCTION a5_cell_to_boundary(cell_id bigint)
RETURNS double precision[][]
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
STRICT
AS $$
  SELECT array_agg(ARRAY[coords[i*2-1], coords[i*2]] ORDER BY i)
  FROM a5_cell_to_boundary_internal(cell_id) AS coords,
       generate_series(1, array_length(a5_cell_to_boundary_internal(cell_id), 1) / 2) AS i;
$$;

CREATE OR REPLACE FUNCTION a5_cell_to_boundary(cell_id bigint, closed_ring bool)
RETURNS double precision[][]
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
STRICT
AS $$
  SELECT array_agg(ARRAY[coords[i*2-1], coords[i*2]] ORDER BY i)
  FROM a5_cell_to_boundary_internal(cell_id, closed_ring) AS coords,
       generate_series(1, array_length(a5_cell_to_boundary_internal(cell_id, closed_ring), 1) / 2) AS i;
$$;

CREATE OR REPLACE FUNCTION a5_cell_to_boundary(cell_id bigint, closed_ring bool, segments int)
RETURNS double precision[][]
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
STRICT
AS $$
  SELECT array_agg(ARRAY[coords[i*2-1], coords[i*2]] ORDER BY i)
  FROM a5_cell_to_boundary_internal(cell_id, closed_ring, segments) AS coords,
       generate_series(1, array_length(a5_cell_to_boundary_internal(cell_id, closed_ring, segments), 1) / 2) AS i;
$$;
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:275

DO $wrapper$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'postgis') THEN
    BEGIN
      -- Get the schema name for geometry type
      DECLARE
        geom_schema text;
      BEGIN
        SELECT n.nspname INTO geom_schema
        FROM pg_type t
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE t.typname = 'geometry'
        LIMIT 1;
        
        -- Create function with schema-qualified geometry type
        EXECUTE format('
          CREATE OR REPLACE FUNCTION a5_point_to_cell(geom %I.geometry, res int)
          RETURNS bigint
          LANGUAGE sql
          IMMUTABLE
          PARALLEL SAFE
          STRICT
          AS $f$
            SELECT a5_lonlat_to_cell(%I.ST_X(geom), %I.ST_Y(geom), res);
          $f$;
          
          CREATE OR REPLACE FUNCTION a5_cell_to_point(cell_id bigint)
          RETURNS %I.geometry
          LANGUAGE sql
          IMMUTABLE
          PARALLEL SAFE
          STRICT
          AS $f$
            SELECT %I.ST_SetSRID(%I.ST_MakePoint(coords[1], coords[2]), 4326)
            FROM (SELECT a5_cell_to_lonlat(cell_id) AS coords) AS t;
          $f$;
          
          CREATE OR REPLACE FUNCTION a5_cell_to_geom(cell_id bigint)
          RETURNS %I.geometry
          LANGUAGE sql
          IMMUTABLE
          PARALLEL SAFE
          STRICT
          AS $f$
            WITH boundary AS (
              SELECT a5_cell_to_boundary(cell_id) AS coords
            )
            SELECT %I.ST_SetSRID(
              %I.ST_MakePolygon(
                %I.ST_MakeLine(
                  array_agg(
                    %I.ST_MakePoint(coords[i][1], coords[i][2])
                    ORDER BY i
                  )
                )
              ),
              4326
            )
            FROM boundary,
                 generate_series(1, array_length((SELECT coords FROM boundary), 1)) AS i;
          $f$;
        ', geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema, geom_schema);
      END;
    EXCEPTION WHEN OTHERS THEN
      -- Ignore errors (e.g., if PostGIS functions don't exist)
      NULL;
    END;
  END IF;
END;
$wrapper$;
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:354

CREATE OR REPLACE FUNCTION a5_lonlat_to_cell(lon numeric, lat numeric, res int)
RETURNS bigint
LANGUAGE sql
IMMUTABLE
PARALLEL SAFE
STRICT
AS $$
  SELECT a5_lonlat_to_cell(lon::double precision, lat::double precision, res);
$$;
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:153
-- a5pg::a5_cell_area
CREATE  FUNCTION "a5_cell_area"(
	"resolution" INT /* i32 */
) RETURNS double precision /* f64 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_area_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:64
-- a5pg::a5_cell_to_boundary_internal
CREATE  FUNCTION "a5_cell_to_boundary_internal"(
	"cell_id" bigint, /* i64 */
	"closed_ring" bool /* bool */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
STRICT 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_boundary_closed_ring_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:74
-- a5pg::a5_cell_to_boundary_internal
CREATE  FUNCTION "a5_cell_to_boundary_internal"(
	"cell_id" bigint, /* i64 */
	"closed_ring" bool, /* bool */
	"segments" INT /* i32 */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
STRICT 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_boundary_full_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:55
-- a5pg::a5_cell_to_boundary_internal
CREATE  FUNCTION "a5_cell_to_boundary_internal"(
	"cell_id" bigint /* i64 */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
STRICT 
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_boundary_internal_flat_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:135
-- a5pg::a5_cell_to_children
CREATE  FUNCTION "a5_cell_to_children"(
	"cell_id" bigint, /* i64 */
	"target_resolution" INT /* i32 */
) RETURNS bigint[] /* alloc::vec::Vec<i64> */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_children_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:42
-- a5pg::a5_cell_to_lonlat
CREATE  FUNCTION "a5_cell_to_lonlat"(
	"cell_id" bigint /* i64 */
) RETURNS double precision[] /* core::option::Option<alloc::vec::Vec<f64>> */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_lonlat_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:120
-- a5pg::a5_cell_to_parent
CREATE  FUNCTION "a5_cell_to_parent"(
	"cell_id" bigint, /* i64 */
	"target_resolution" INT /* i32 */
) RETURNS bigint /* i64 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_cell_to_parent_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:189
-- a5pg::a5_compact
CREATE  FUNCTION "a5_compact"(
	"cell_ids" bigint[] /* alloc::vec::Vec<i64> */
) RETURNS bigint[] /* alloc::vec::Vec<i64> */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_compact_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:159
-- a5pg::a5_get_num_cells
CREATE  FUNCTION "a5_get_num_cells"(
	"resolution" INT /* i32 */
) RETURNS bigint /* i64 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_get_num_cells_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:172
-- a5pg::a5_get_res0_cells
CREATE  FUNCTION "a5_get_res0_cells"() RETURNS bigint[] /* alloc::vec::Vec<i64> */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_get_res0_cells_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:113
-- a5pg::a5_get_resolution
CREATE  FUNCTION "a5_get_resolution"(
	"cell_id" bigint /* i64 */
) RETURNS INT /* i32 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_get_resolution_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:25
-- a5pg::a5_lonlat_to_cell
CREATE  FUNCTION "a5_lonlat_to_cell"(
	"lon" double precision, /* f64 */
	"lat" double precision, /* f64 */
	"resolution" INT /* i32 */
) RETURNS bigint /* i64 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_lonlat_to_cell_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:207
-- a5pg::a5_uncompact
CREATE  FUNCTION "a5_uncompact"(
	"cell_ids" bigint[], /* alloc::vec::Vec<i64> */
	"target_resolution" INT /* i32 */
) RETURNS bigint[] /* alloc::vec::Vec<i64> */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5_uncompact_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:16
-- a5pg::a5pg_info
CREATE  FUNCTION "a5pg_info"() RETURNS jsonb /* pgrx::datum::json::JsonB */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5pg_info_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:10
-- a5pg::a5pg_version
CREATE  FUNCTION "a5pg_version"() RETURNS TEXT /* &str */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'a5pg_version_wrapper';
/* </end connected objects> */

